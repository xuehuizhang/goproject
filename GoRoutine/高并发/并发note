1, 异步回调async callback （回调函数）
    利弊：
        效率高
        回调地狱 Callback Hell,逻辑线不清晰

2，共享内存
    线程并发交互数据：通过共享内存
    线程并发弊端：
        开线程占内存
        啥也不干就拿走1M栈空间
        1024条线程就占用1G内存
        线程切换占CPU
        内存共享不安全
        加了锁效率又低下
    异步并发：
    回调地狱导致开发难度高

3，CSP并发模型
    Communicating Sequential Process
    可通信的序列化进程
    并发的进程间通过管道进行通信

    共享内存 VS 管道
        1，内存共享:通过内存共享通信
        2，管道:通过通信共享内存

    go并发借用进程通过管道的方式进行通信

并行/并发：
    并行：真并行
        1，在同一时刻多条指令在多个Cpu上执行，借助多核实现
    并发：假并行，但是时间轮片切换速度快
        1，宏观并发
            1，用户体验上，程序在并行执行
        2，微观并发
            1，多个计划任务，顺序执行，在飞快的切换，轮换使用cpu时间轮片

常见的并发编程技术：
    1，进程并发：fork
        程序：编译成功得到的二进制文件      占用磁 盘空间             剧本     1
        进程：运行起来的程序                占用系统资源（内存）     戏        n

    2，进程状态
        初始态：
        就绪态：等待cpu分配时间轮片
        运行态：占用cpu
        挂起态：等待cpu以外的其他资源，主动放弃cpu  ---就绪态---运行态
        停止态：
    3，孤儿进程：父进程先与子进程结束
    4，僵尸进程：进程终止，父进程未回收

    线程并发：
        线程：lwp轻量级的进程   最小的执行单位---cpu分配时间轮片的对象
        进程：最小的资源分配单位  4G进程地址空间，windows系统下进程只给线程提供执行环境（4G）

    同步：
        1，协同步调，规划执行顺序，避免数据混乱，所有的多个控制流访问共享资源都需要同步：先加锁
        2，线程同步机制：
            互斥锁（互斥量）：建议锁，拿到锁后，才能访问数据，没有拿到锁的线程，阻塞等待，等到拿到锁的线程释放锁  （对读操作互斥锁也会起作用）
            读写锁：一把锁（读属性，写属性）写独占，读共享，写锁优先于级高
            互斥量
            条件变量
    协程并发：轻量级的线程
        1，设计的初期目的是为了提高程序执行效率

    总结：
        进程，线程，协程 都可以完成并发：
            1，进程并发稳定性好，linux系统中就是进程并发，但是开销大
            2，线程并发节省资源
            3，协程效率高

        案例：
        老板---手机

        生产线----设备，材料，厂房---进程（资源分配单位）
        工人----线程    -------单进程，单线程程序
        50工人-----50线程    -----单进程，多线程的程序
        10条生产线-----500工人   ---多进程，多线程
        利用闲暇时间义务搬砖---协程     --多进程，多线程，多协程

     mmu---将虚拟地址映射到实际硬件地址
     4G内存：虚拟地址，用了多少，mmu在物理内存上映射多少

go并发：在语言级别支持并发
    1，实现并发：goroutine  channel
    2，go语言并发忽略线程，但是必须存在进程
    3，go程创建于进程中，直接使用go关键字，放置于函数调用前，产生一个go程/并发

go程序特性：
    1，主go程结束，子go程随之退出，主go程结束，相当于进程结束

常用包：
    runtime:
        1，Gosched  用于让出cpu时间片   当再次获得时在出让位置继续执行   时间片轮转调度算法
        2，time.sleep  是因为睡眠才出让cpu时间片，在定时时间到，会获得cpu执行机会
        3，Goexit
            return：返回当前调用到调用者，return 后续的不会执行，如果defer在return之前没有注册，defer也不会执行
            Goexit：结束调用该函数的go程，在go程中 在Goexit之后的不会执行，之前注册的defer执行，之后的defer也不执行

        4，GOMAXPROCS 设置可以并行计算的核数
        runtime中其他函数
            1，GOROOT  返回go根目录
            2，Version
            3, NumCPU  逻辑cpu个数
            4, GC 垃圾回收
            5，MemStats 内存操作

Channel
    1，管道 并发核心单元
        channel是一种数据类型,对应一个管道（通道），用来解决go程同步问题以及数据共享（传递数据）
        goroutine通过通信共享内存，而不是共享内存来通信
        channel底层通过csp同步机制实现并发同步
    2，定义channel变量  引用类型
        make(chan type,int n)  n=0  无缓冲  n!=0  有缓冲  默认 0

    3，补充知识点：每当一个进程启动，系统会打开三个文件 标准输入  标准输出  标准错误  stdin stdout stderr
        当进程结束，操作系统自动关闭三个文件

    4, 总结
        channel存在两个端，一端写入，必须有另一端在读取，不然会阻塞
        使用channel与加锁的区别，锁的粒度比较难把握

总结：

数据通信：
    1，写端： ch<-"hello"  写端写数据，读端不在线 阻塞
    2，读端： <-ch         读端读数据，同时写端不在线，读端堵塞
    阻塞产生的原因：两端没有同时到位
channel同步：数据传递
        无缓冲的channel：
            1，无缓冲的channel  len与cap始终为0，因此不能存储数据
            2，channel应用于至少两个go程中，一个读，另外一个写
            3，具备同步的能力(重点)

        有缓冲的channel:
            1,通道容量为非0，len:channel中剩余未读取数据的个数
            2，缓冲区可以进行数据存储，存储至容量上限，阻塞，不需要同时操作channel缓冲区（短信）
            3，具有异步的能力(重点)
            4，channel应用于至少两个go程中，一个读，另外一个写

        关闭channel:
            1,使用close关闭channel,对端可以判断channel是否关闭
            确定不在向对端发送，接收数据，关闭channel,一般关闭发送端
                    if num,ok:=<-ch;ok==true{
                        对端已经关闭  ok---false，num无数据
                        对端没有关闭  ok---true, num保存读取到的数
                    }

        总结：
            1，数据没有发送完，不应该关闭
            2，已经关闭的channel,不能写入数据，
            3，但是可以读取,读取到 0，说明写端关闭
                1，读无缓冲channel,读取到0
                2，读有缓冲channel,如果缓冲区有数据，先读数据，后读取到 0

        补充：读取已经关闭channel方法：
            1, range
            2, if

        单向channel: 默认是双向  var ch chan int   ch:=make(chan int)
            1，单向写  var senCh chan <- int   ch:=make(chan <- int)

            2，单向读  var recvCh <- chan int  ch:=make(<-chan int)

            转换：传参 传引用
                双向channel可以隐式转换为任意一种单向channel
                单向channel不能转换为双向channel

生产者/消费者模型
        缓冲区：
            1，降低生产者和消费者之间的耦合度  解耦
            2，提高并发能力  生者者消费者数量不对等时，仍然可以保持通信
            3，缓存作用  生产者消费者  数据处理速度不一致时，暂存数据
        生产者：
        消费者：

定时器：三种定时方法  time.sleep  time.After  time.NewTimer
        1，Timer: 表示一个定时时长,定时到达后，系统自动向定时器成员写系统当前当前时间  对chan的写操作
                type Timer struct {
                	C <-chan Time
                	r runtimeTimer
                }

                myTimer:=time.NewTimer(time.Second*2)
            	nowTime:=<-myTimer.C
        2,定时器重置和停止
            myTime.Stop  停止   <-myTimer.C会阻塞
            myTime.Reset 重置
        3，定时器周期定时
            	myTicker:=time.NewTicker(time.Second)  //周期定时器

select基础语法：
    特性：每个case里面必须时IO操作，读管道也是IO操作
    忙轮询死循环：特别消耗资源，因此select中不写default
    注意事项：
        1，监听的case中，没有满足监听条件阻塞
        2，监听的case中，有多个满足监听条件，任选一个执行
        3，可以使用default来处理所有case都不满足监听条件的状况，通常不用
        4，select自身不带有循环机制，需要借助外层for循环监听
        5，break只能跳出select，类似于switch中用法